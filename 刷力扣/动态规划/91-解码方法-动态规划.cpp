/*
题目：
- 一条包含字母A-Z的消息通过以下映射进行了编码：
    'A' -> "1"
    'B' -> "2"
    ...
    'Z' -> "26"
- 要解码已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母(可能有多种方法)。例如，"11106"可以映射为：
    "AAJF"，将消息分组为 (1 1 10 6)
    "KJF"，将消息分组为 (11 10 6)
- 注意：消息不能分组为(1 11 06)，因为"06"不能映射为"F"，这是由于"6"和"06"在映射中并不等价。
- 给你一个只含数字的非空字符串s，请计算并返回解码方法的总数 。
- 题目数据保证答案肯定是一个32位的整数。

思路->动态规划：
- 假设dp[i]为字符串s中第i个字符的解码方法数
- 那么dp[i]的值取决于什么呢？
    - 如果s[i]不为0，那么显然dp[i] = dp[i - 1] + dp[i - 2];    // 这个应该不难理解，应该说是很容易理解了
        -- dp[i - 2]能不能加上，取决于s[i-1]与s[i]构成的字符是否在10~26之间，如果能，则加，否则没法加；
    - 如果s[i]确为0，那么显然dp[i] = dp[i - 2];   
        - value的值取决于s[i - 1]和s[i]构成的数是否在10~26之间，如果在，那么就应该加上dp[i - 2]；
        - 否则只能为0，因为这两个数构不成一个合理的编码值

- 最终代码优化了代码的写法，更简洁精炼        
*/
#include "../headfile/io_for_leetcode.h"
using namespace std;


int numDecodings(string s)
{
    int size = s.size();
    if(s[0] == '0')    return 0;   // 如果存在前导0，那么返回值必定为0，不可能可以正常解码
    
    vector<int> dp_array(size + 1); // 动态规划数组多设置一位

    dp_array[0] = 1;    // 第0个位置，即没给定字符串s时，解码方法为1(空码)

    for(int i = 1; i <= size; i++)
    {
        if(s[i - 1] != '0') // 如果第一个字符转为编码目标后不为0
        {
            dp_array[i] += dp_array[i - 1]; // 显然可以确定dp_array[i]可以先加上dp_array[i - 1]
        }
        
        // 接下来判断前2个
        if (i > 1 && s[i - 2] != '0' && (s[i - 2] - '0') * 10 + (s[i - 1] - '0') <= 26)
            dp_array[i] += dp_array[i - 2];
    }
    return dp_array[size];
}

int main()
{
    string input;
    cin >> input;

    cout << numDecodings(input) << endl;

    return 0;
}
