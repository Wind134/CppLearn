/*
题目：
- 给定一个包含红色、白色和蓝色、共n个元素的数组nums，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
- 我们使用整数0、1和2分别表示红色、白色和蓝色。(也就是说，整个数组都只有这三个数字)
- 必须在不使用库内置的sort函数的情况下解决这个问题。

Notes：本质上就是要求我们实现一遍排序算法，那就再手写一遍归并吧

思路：双指针法
- 设定两个指针p0, p1，p0指针用于交换0，p1指针用来交换1，初始位置均为0；
- 两个指针的实际意义是，在这两个指针之前的数都是0，或者1(初始位置除外)
- 然后开始遍历给定的数组，如果遍历的是0，那么将该位置的值与num[p0]做交换，p0递增，这个时候p1也需要递增，因为再怎么样，p0之前的位置一定是分配好了的
- 因为p0代表的是0，0一定在1的前面；
- 如果遇到的是1，那么这个时候就需要将p1的位置的元素与nums[i]进行交换，这个时候只需要单独递增p1，p0保持在之前的位置即可；
- 最后需要考虑的一个问题是，万一是先遇到1后遇到0呢，这确实是个问题，这个时候就需要一定的手段妥善处理；
- 我们在这种场景下可以确保的一点是：p0之前的元素一定是0，p1之前的元素一定是0或1，关键之处就在于这个"或"字
    -- "或"字体现了一个顺序，先0后1，或者先1后0；
    -- 先0后1是正常情况，先1后0则是需要特殊处理的情况；
- 结合代码去判断这个过程    
*/
#include "../headfile/io_for_leetcode.h"
using namespace std;

void sortColors(vector<int>& nums)
{
    int size = nums.size();
    int p_0 = 0, p_1 = 0;
    for (int i = 0; i < size; ++i)
    {
        if (nums[i] == 0) {
            swap(nums[i], nums[p_0]);   // 0被交换到了该去的地方

            // 接下来就是我们要考虑的特殊情况，万一是先排好了1后遇到0的情况呢，这种情况下，p0一定在p1的前面
            if (p_0 < p_1)  swap(nums[i], nums[p_1]);   // 注意，这个nums[i]已经是被交换过的了，我们将这个数放在p1所处的那个位置
            ++p_0;
            ++p_1;
        } else if (nums[i] == 1) {
            swap(nums[i], nums[p_1]);
            ++p_1;
        }
    }
}


int main()
{
    input input75;
    auto input_vec = input75.input_vector();
    sortColors(input_vec);
    output output75;
    output75.output_array(input_vec);

    return 0;
}